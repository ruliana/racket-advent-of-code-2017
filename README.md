# Advent of Code 2017 - Racket

I'd like to improve my Racket-fu and to practice some programming techniques, so I took the [Advent of Code 2017](http://adventofcode.com/2017) challenge and start to solve it the most interesting ways I could.

By "interesting" I mean I experimented with different techniques:

- For the most mathematical challenges, I try to move away from loops and recursion and tried a ["closed form"](http://mathworld.wolfram.com/Closed-FormSolution.html) solution. In other words, I tried to find a set of equations that gives the result instead of computing every step of it. The day-03a-spiral problem is a very good exemple of it.
- For the parsing challenges, my first thought is to go for regular expression (the Perl style). In day 08 I moved away from it and experimented with the Racket infrastructure for language building. At this point, [Beautiful Racket](https://beautifulracket.com/) from Matthew Butterick was invaluable.
- Where possible, I tried to exercise some less common "day-by-day" techniques (at least in a Ruby/Python/R/Java/Javascript point of view), like _side band_ argument passing (Racket "parameters"), recursion, pattern matching, function composition, macros, etc...
- Overall, I tried to avoid deep nesting as much as I could. So, there is profusion of "helper methods" or "convenience methods" and variables. I find this a sane approach to every new language, actually.

## The challenges

### [Day 01](http://adventofcode.com/2017/day/1) - Inverse Captcha

There is a sequence of numbers and we need to find the sum of repeated ones at a certain distance.

Instead of trying to loop over the indexes, I used "in-cycle" to create a circular list (actually, a stream) and "sequence-tail" to displace it. Then a simple list comprehension with "for/sum" and ":#when" solves the problem.

Note: The sequence and list functions of Racket are awesome, but they fall a little short on vectors and dictionaries (hashtables), the awesome ("collections")[https://docs.racket-lang.org/collections/index.html] library from Alexis King cover this beautifully. 

### [Day 02](http://adventofcode.com/2017/day/2) - Corruption Checksum

From a sequence of rows, find the difference between the largest and smallest number or each row. Later, you need to find pairs that are evenly divisible.

This challenge is easy as you need only a "max" and "min" functions. The second part is a bit harder, but "in-combinations" functions does the trick.

### [Day 03](http://adventofcode.com/2017/day/3) - Spiral Memory

From a spiral sequence of integers, find the manhattan distance to a given point. Part two is a spiral generated by summing neighbors ([_the spiral sequence_](https://oeis.org/A141481)).

First part is the best! I spend a couple of hours trying to figure out how to get a closed form for it, just to discover I need to generate the sequence anyway for the second part.

The solution was reduced to a single number, it's whole part is the distance from the center and the fractional part is the angle where the number is. This is very similar to a polar coordinates, but using a single number.

### [Day 04](http://adventofcode.com/2017/day/4) - High-Entropy Passphrases

Basically, find similarities in a list of strings.

The problem is simple, but it let me play with a few interesting techniques. First of all the ("macro threading")[https://docs.racket-lang.org/threading/index.html] borrowed from Clojure for function composition (thanks to Alexis King, again).

Second, the "parameters" from Racket itself. It's a nice way to configure things without the global problem. There is a similar technique using "thread local" variables and "try/finally"/"begin/ensure" in Java and Ruby. I find the technique very useful, but underestimated.

### [Day 05](http://adventofcode.com/2017/day/5) - A Maze of Twisty Trampolines, All Alike

Jump through a list of integers, following their relative positions and mutating it as you go through.

Here I used two recursive functions that call each other ("jump" and "stop-condition" inside the "walk-through" function). The technique is very interesting, it reduces the nesting, also it keeps the logic separated between acting (jump) and checking (stop-condition).

Unfortunately this can be used only in Scheme like languages, as others barely have tail call optimization. However, using a loop here and a stop condition is actually pretty good. So it's not a big deal, but it was fun to "trampoline" things around :D

### [Day 06](http://adventofcode.com/2017/day/6) - Memory Reallocation

Similar to day 05, rom a list of integers, jump and mutate things around.

Here I experimented with something similar to a "closed form" solution. Instead of starting the loop from the highest number an deal with a circular list (a totally valid approach), I always start from the first position and calculate the results from there. This allowed me to use a simple "for/vector" and completely avoid mutability. This make the whole thing a very interesting exercise and very easy to detect cycles :D

### [Day 07](http://adventofcode.com/2017/day/7) - Recursive Circus

From a dependency list, create a tree. Later, find where the numbers don't sum up correctly in the tree.

Here I tried the immutable approach first, but it got too much complicated. The mutable one was faaaaaar simpler. I recommend you to experiment with both, it's very interesting and it gives great insight about the mutable vs immutable balance (at least for me).

Apart from the tree building, the second part is a legit use of recursion. Every time I deal with trees, recursion seems very natural.

Note: the first part of the problem can be solved without actually building the tree, just build the list and remove the ones found in the dependency list, the last one standing is the answer ^_^

### [Day 08](http://adventofcode.com/2017/day/8) - Heard You Like Registers

This is a very simple language implementation that deals with "infinite" registers.

I overengineered this big time! I used this challenge to experiment creating a full language in Racket. It was great!

There are lots of files, but all them are really small. The thing starts in the "-reader.rkt" file, it uses a very simple lexer to generate tokens and a parser to generate an AST (Abstract Syntax Tree) from these tokens. Finally, the "expander" uses macros to transform the AST to simple Racket function calls and it's done.

My feeling it that the hard parts are the "glue" between lexer, parser and expander, not the language building _per se_. I guess I could abstract it in a form of "convention over configuration" to make things easier, pretty much what the (["brag")[http://docs.racket-lang.org/brag/] (from Danny Yoo and Matthew Butterick) library does.

Thanks for the (Beautiful Racket)[https://beautifulracket.com/] from Matthew Butterick, it would be a rough journey without it.
